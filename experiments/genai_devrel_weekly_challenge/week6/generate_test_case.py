"""
Copyright 2025 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import json
import os
from typing import List, Dict, Any
import typer
from tqdm import tqdm
import PIL.Image
from pydantic import BaseModel

# Import necessary modules from index.py
from index import (
    list_genai_l200_files,
    read_pdf_from_gcs,
)
from settings import get_settings, BUCKET_NAME, IMAGE_PREFIX, PDF_PREFIX
from google import genai
import tempfile
from google.cloud import storage
import hashlib

# Initialize settings
settings = get_settings()

# Create a temporary directory for cached files if not exists
TEMP_DIR = tempfile.mkdtemp(prefix="gcs_cache_")

PROMPT = """
You are an expert travel agent.
Based on the following documents and images content, generate {num_questions} question-answer pairs
that might come from user perspective.
Each question should test understanding of the document content.
Format your response as a JSON array of objects, each with 'question' and 'answer' fields.
The documents and images are complementing each other about tourism in Florence

DOCUMENT CONTENT:
{pdf_contents}

IMAGE CONTENT:
"""


class QuestionAnswerPair(BaseModel):
    """Model for question-answer pairs generated by Gemini."""

    question: str
    answer: str


# Dictionary to cache file paths
FILE_CACHE: Dict[str, str] = {}


def download_gcs_file(gcs_uri: str) -> str:
    """Download a file from Google Cloud Storage and cache it locally.

    This function checks if the file is already in the cache before downloading.
    If it's not in the cache, it downloads the file from GCS and stores it in
    a temporary directory with a filename based on the MD5 hash of the URI.

    Args:
        gcs_uri: GCS URI in the format gs://bucket-name/path/to/file

    Returns:
        str: Path to the local file

    Raises:
        ValueError: If the GCS URI format is invalid
    """
    # Check if file is already in cache
    if gcs_uri in FILE_CACHE and os.path.exists(FILE_CACHE[gcs_uri]):
        return FILE_CACHE[gcs_uri]

    # Parse GCS URI
    if not gcs_uri.startswith("gs://"):
        raise ValueError(f"Invalid GCS URI: {gcs_uri}")

    # Remove 'gs://' prefix and split into bucket and blob path
    uri_parts = gcs_uri[5:].split("/", 1)
    if len(uri_parts) != 2:
        raise ValueError(f"Invalid GCS URI format: {gcs_uri}")

    bucket_name, blob_path = uri_parts

    # Create a hash of the URI to use as filename
    file_hash = hashlib.md5(gcs_uri.encode()).hexdigest()
    file_ext = os.path.splitext(blob_path)[1]
    local_path = os.path.join(TEMP_DIR, f"{file_hash}{file_ext}")

    # Download file if it doesn't exist
    if not os.path.exists(local_path):
        storage_client = storage.Client()
        bucket = storage_client.bucket(bucket_name)
        blob = bucket.blob(blob_path)
        blob.download_to_filename(local_path)

    # Cache the file path
    FILE_CACHE[gcs_uri] = local_path
    return local_path


def main(
    output_file: str = "test_cases.json",
    num_pdf_questions: int = 10,
    num_image_questions: int = 10,
    total_questions: int = 20,
) -> None:
    """Generate test cases from PDFs and images in Google Cloud Storage.

    This function:
    1. Retrieves PDFs and images from GCS
    2. Extracts content from PDFs
    3. Downloads and processes images
    4. Uses Gemini to generate question-answer pairs based on the content
    5. Saves the generated test cases to a JSON file

    Args:
        output_file: Path to output JSON file
        num_pdf_questions: Number of questions to generate per PDF
        num_image_questions: Number of questions to generate per image
        total_questions: Total number of questions to include in final output
    """
    # Get list of PDFs and images
    pdf_files = list_genai_l200_files(PDF_PREFIX)
    image_files = list_genai_l200_files(IMAGE_PREFIX)

    test_generation_prompt: List[Any] = []

    pdf_contents = ""
    # Load PDF content
    print(f"Processing {len(pdf_files)} PDF files...")
    for pdf_file in tqdm(pdf_files):
        pdf_contents += read_pdf_from_gcs(BUCKET_NAME, pdf_file)

    test_generation_prompt.append(
        PROMPT.format(pdf_contents=pdf_contents, num_questions=25)
    )

    # Load Image content
    print(f"Processing {len(image_files)} image files...")
    for image_file in tqdm(image_files):
        image_path = f"gs://{BUCKET_NAME}/{image_file}"
        local_file_path = download_gcs_file(image_path)
        pil_image = PIL.Image.open(local_file_path)

        test_generation_prompt.append(pil_image)

    print("Generating question-answer pairs with Gemini...")
    client = genai.Client(api_key=settings.GEMINI_API_KEY)
    response = client.models.generate_content(
        model="gemini-2.0-flash",
        contents=test_generation_prompt,
        config={
            "response_mime_type": "application/json",
            "response_schema": list[QuestionAnswerPair],
        },
    )

    data = response.parsed

    # Convert Pydantic models to dictionaries
    serializable_data = [qa_pair.model_dump() for qa_pair in data]

    # Save to JSON file
    with open(output_file, "w") as f:
        json.dump(serializable_data, f, indent=2)

    print(f"Generated {len(serializable_data)} test cases and saved to {output_file}")
    print(
        f"Sample question: {serializable_data[0]['question'] if serializable_data else 'No questions generated'}"
    )


if __name__ == "__main__":
    typer.run(main)
